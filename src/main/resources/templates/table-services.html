<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Список услуг</title>
    <link rel="stylesheet" th:href="@{/css/table-pagination.css}">
</head>
<body>


<!-- Кнопка для создания категории/услуги -->
<div>
    <span>Создать услугу/категорию: </span>
    <a th:href="@{/service/create}">
        <button type="button">Создать</button>
    </a>
</div>


<h1>Список услуг</h1>


<!-- Подключаю всплывающее уведомление -->
<div th:replace="~{fragments/toast :: toast}"></div>


<!-- Фильтрация по категории -->
<form th:action="@{/service/list}" method="get">
    <label for="category">Выберите категорию:</label>
    <select id="category" name="categoryId">
        <option value="" th:selected="${selectedCategoryId == null}">Все категории</option>
        <option th:each="category : ${categories}"
                th:value="${category.id}"
                th:text="${category.name}"
                th:selected="${category.id == selectedCategoryId}"></option>
    </select>
    <button type="submit">Фильтровать</button>
</form>


<!--Поле для поиска-->
<div>
    <label for="searchInput">Поиск по наименованию:</label>
    <input type="text" id="searchInput" onkeyup="searchByName('servicesTable', 'searchInput')"
           placeholder="замена сцепления">
</div>


<!-- Контейнер для таблицы и пагинации -->
<div class="table-container">
    <!-- Обертка для таблицы -->
    <div class="table-wrapper">
        <!-- Таблица услуг -->
        <table id="servicesTable">
            <thead>
            <tr>
                <th>Название услуги</th>
                <th>Описание</th>
                <th>Категория</th>
                <th>Удаление</th>
            </tr>
            </thead>
            <tbody>
            <!-- Если услуг нет, выводим сообщение -->
            <tr th:if="${#lists.isEmpty(services)}">
                <td colspan="4" style="color: red; text-align: center;">Услуги отсутствуют</td>
            </tr>

            <!-- Отображение услуг -->
            <tr th:each="service, iterStat : ${services}">
                <td th:text="${service.name}"></td>
                <td th:text="${service.description}"></td>
                <td th:text="${service.category.name}"></td>
                <td>
                    <form th:action="@{/service/delete}" method="post">
                        <input type="hidden" name="id" th:value="${service.id}">
                        <button type="submit">Удалить</button>
                    </form>
                </td>
            </tr>
            </tbody>
        </table>
    </div>

    <!-- Пагинация -->
    <div class="pagination-container">
        <div class="pagination">
            <!-- Стрелка назад -->
            <span class="pagination-arrow">
            <a id="prevPage" href="#" onclick="changePage(currentPage - 1)" aria-disabled="false">«««</a>
            <span id="prevPageDisabled" style="display: none;">«««</span>
        </span>

            <span id="currentPageNumber">1</span> из <span id="totalPages">1</span>

            <!-- Стрелка вперед -->
            <span class="pagination-arrow">
            <a id="nextPage" href="#" onclick="changePage(currentPage + 1)" aria-disabled="false">»»»</a>
            <span id="nextPageDisabled" style="display: none;">»»»</span>
        </span>
        </div>
    </div>
</div>


<script>
    let currentPage = 0;
    const rowsPerPage = 2;
    let totalRows = 0;
    let filteredRows = [];
    document.addEventListener('DOMContentLoaded', initializePagination);


    function initializePagination() {
        const rows = document.querySelectorAll('#servicesTable tbody tr');
        filteredRows = Array.from(rows); // Сохраняем все строки в массив
        totalRows = filteredRows.length; // Считаем все строки
        updatePagination(totalRows); // Обновляем пагинацию сразу при инициализации
    }


    function updateTableDisplay() {
        const startIndex = currentPage * rowsPerPage;
        const endIndex = Math.min(startIndex + rowsPerPage, totalRows);

        filteredRows.forEach((row, index) => {
            if (index >= startIndex && index < endIndex) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });

        document.getElementById('currentPageNumber').innerText = currentPage + 1;
    }


    function changePage(page) {
        const totalPages = Math.ceil(totalRows / rowsPerPage);
        if (page >= 0 && page < totalPages) {
            currentPage = page;
            updateTableDisplay();
            updatePaginationButtons(totalPages);
        }
    }


    function updatePaginationButtons(totalPages) {
        const prevPage = document.getElementById('prevPage');
        const nextPage = document.getElementById('nextPage');
        const prevPageDisabled = document.getElementById('prevPageDisabled');
        const nextPageDisabled = document.getElementById('nextPageDisabled');

        // Стрелка назад
        if (currentPage > 0) {
            prevPage.style.display = 'inline';  // Показываем активную стрелку
            prevPageDisabled.style.display = 'none';  // Скрываем неактивную стрелку
        } else {
            prevPage.style.display = 'none';  // Скрываем активную стрелку
            prevPageDisabled.style.display = 'inline';  // Показываем неактивную стрелку
        }

        // Стрелка вперед
        if (currentPage < totalPages - 1) {
            nextPage.style.display = 'inline';  // Показываем активную стрелку
            nextPageDisabled.style.display = 'none';  // Скрываем неактивную стрелку
        } else {
            nextPage.style.display = 'none';  // Скрываем активную стрелку
            nextPageDisabled.style.display = 'inline';  // Показываем неактивную стрелку
        }
    }


    function searchByName(tableId, inputId) {
        const filter = document.getElementById(inputId).value.toLowerCase();
        const rows = document.getElementById(tableId).getElementsByTagName('tr');
        filteredRows = [];  // Очищаем массив отфильтрованных строк

        for (let i = 1; i < rows.length; i++) {
            const cellText = rows[i].cells[0]?.textContent || '';
            if (cellText.toLowerCase().includes(filter)) {
                filteredRows.push(rows[i]);  // Добавляю строку в массив отфильтрованных
            } else {
                rows[i].style.display = 'none';
            }
        }

        totalRows = filteredRows.length; // Пересчитываем количество строк после фильтрации
        currentPage = 0;  // Возвращаюсь на первую страницу при изменении поиска
        updatePagination(totalRows); // Обновляем пагинацию после изменения фильтра
    }


    function updatePagination(totalRows) {
        const totalPages = Math.ceil(totalRows / rowsPerPage);
        document.getElementById('totalPages').innerText = totalPages;
        updateTableDisplay();
        updatePaginationButtons(totalPages);
    }
</script>


</body>
</html>
